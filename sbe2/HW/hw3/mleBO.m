function varargout = mleBO(varargin)% MLEM3 - simulate Morris-Lecar equations, augmented with a 3rd (Ca) state% variable. This version has all subroutines in one package.%     [VV, tV, pml3, iext] = mleBO(tdur, pml3, iext);% All inputs and outputs are optional, but variables must be provided in the% order given and both VV and tV must be present if one is; similarly% for pml3 and iext.%  tdur = duration of the simulation in ms  (defaults to 1000).%  pml3 = a vector of parameters for the model.%       = [gca, gk, gl, vca, vk, vl, phi, v1, v2, v3, v4, v5, v6, C, vic, ...%           wic, eps, mu, gkca, Caic Kc]'%  iext = [Iext value, tstart, tstop]   current Iext is injected over the%          times [tstart, tstop].% The model is taken from Rinzel and Ermentrout, 1998. NOTE that this is% somewhat different in parameter values, because the params in R&E don't% seem to work.% If there are no input parameters, then a working set will be set up% internally.% Check inputs and set default values if not provided.if nargin>0    tdur = varargin{1};else    tdur = 1000;end% If pml3 is provided, iext must be provided also.if nargin>1    pml3 = varargin{2};    iext = varargin{3};    fprintf('***Using parameters provided in call.***\n')    fprintf('   Ca parameters: eps=%g, mu=%g, gkca=%g, Kc=%g.***\n', ...          pml3([17,18,19,21]))    whfig = 0;else    % Default set of parameters pml3 is a vector of 21 elements.%        gca, gk, gl,vca,  vk,  vl,  phi,  v1,  v2, v3, v4,  v5, v6, C,    pml3=[4, 8.0, 2, 120, -84, -60, 0.23, -1.2, 18, 12, 17.4,12,17.4,20, ...        -29.6,0.0082,0.005, 0.0133, 0.28, 0.4,  1]';%        vic,  wic    eps     mu    gkca  Caic Kc    % and iext is contains the injected current, start time, and stop time for% the current pulse. Usually this is 45 uA/cm^2 for the whole duration of% the simulation.    iext = [45, -1, 6000]';        fprintf('***Using R&E params for Fig. 7.9 except phi = %g.***\n', ...        pml3(7))    fprintf('***iext set to %g uA/cm^2 DC value.***\n',iext(1))    fprintf('   Ca parameters: eps=%g, mu=%g, gkca=%g, Kc=%g.***\n', ...          pml3([17,18,19,21]))    whfig = 9;end% Set up for the simulationsetmleparms3(pml3, iext);   % Set the parameters for the ODE solvertspan = [0; tdur];        % Simulation durationy0 = pml3([15;16;20]);    % Default initial conditions        %options = odeset('OutputFcn', 'odeplot', 'Jacobian', 'morlecjac3', ...%            'RelTol',1.e-6);options = odeset('OutputFcn', 'odeplot', 'RelTol',1.e-6);        % Simulate 3-D system[tim,y] = ode15s(@mlode3, tspan, y0, options);current = y(size(y,1),:);fprintf('Final values: v=%g,  w=%g, Ca=%g\n',current);% Display results[ax, h1, h2] = plotyy(tim, y(:,1), tim, y(:,3));Vlim = get(ax(1), 'XLim');set(ax(1), 'Ylim', [-40, 40]);set(ax(1), 'YTick', [-40 -30 -20 -10 0 10 20 30 40], ...     'YTickLabel', [-40 -30 -20 -10 0 10 20 30 40])set(get(ax(1), 'YLabel'), 'String', 'V, mV')Ca_axMax = max(1.6, max(y(:,3)));set(ax(2), 'YLim', [0 Ca_axMax]);if Ca_axMax==1.6    set(ax(2), 'YTick', [0 .2 .4 .6 .8 1 1.2 1.4 1.6], ...         'YTickLabel', [0 .2 .4 .6 .8 1 1.2 1.4 1.6])endset(get(ax(2),'YLabel'), 'String', 'Calcium')xlabel('Time, ms.');titl = sprintf( ...'M-L eqns w/ Ca state, vic,wic,Caic=%g mV, %g, %g.  iext=%g uA/cm^2,  Fig. 7.%i params.', ...	        y0(1), y0(2), y0(3), iext(1), whfig);title(titl)if nargout>1    varargout{1} = y; varargout{2} = tim;    if nargout>3        varargout{3} = pml3; varargout{4} = iext;    endendreturnfunction varargout=mlode3(t, y, flag)% MLODE3 - ODE file for the Morris-Lecar Equations with a Ca state.% state vector is [V, w, Ca]'% Evaluates the derivative of the state vector for the Morris-Lecar% equations with parameters pml3, where pml3 is a column vector of params%    pml3=[gca, gk, gl, vca, vk, vl, phi, v1, v2, v3, v4, v5, v6, ...%            C, vic, wic, eps, mu, gkca, Caic, Kc]'%% Calcium is: dCa/dt=eps*(-mu*gca*minfmle(V)*(V-Eca) - Ca)% Ikca is:    Ikca = gkca*Ca/(Ca+Kc)*(V-Ek)%% and iext is a column vector describing the external current%	iext = [iampl, tstart, tstop]'% v5=v3 and v6=v4 are for tauw(); vic, wic, & Caic are needed only for 'init' calls.% eps, mu, and gkca are the params of the calcium state added in R&E fig 7.9.% Program sets other params to value for fig 7.8.% Also responds to 'init' and 'jacobian' flags. % Parameters are set through function SETMLEPARMS3() only.% NOTE: NUMJAC passes the parameter 'flag' differently to odefiles in% different versions of MATLAB. In Mac v5.2, numjac calls the ode file% as mlode(t,y). In PC v5.3, numjac calls as mlode(t,y,'').% To get the Jacobian, proceed in one of the two ways:% 1. t = 0; y = [state vector at the eq. pt. where the jacobian is desired];%    setmleparms3(pml3, iext)     % Set parameters of MLE model%    jac = mlode3(t, y, 'jacobian')  % Returns the jacobian%% 2. t = 0; y = [state vector]; fac = [];%    setmleparms3(pml3, iext)%    [jacn,fac]=numjac('mlode3', t, y, mlode3(t,y,''), [1e-5;1e-5;1e-5],fac,0)	if nargin<3                    % Flag defaults to ''.		flag = '';	end	[pml3, iext] = getmleparms3;	switch flag		case ''                % Return ydot vector			varargout{1} = morlecdot3(t,y,pml3,iext);		case 'init'             % Return default tspan, y0, and options			[varargout{1:3}] = init3(pml3);		case 'jacobian'         % Return Jacobian matrix			varargout{1} = morlecjac3(t,y);		otherwise			error(strcat('***Unknown flag=''',flag,''' in MLODE.***'))	endreturnfunction ydot = morlecdot3(t,y,pml,iext)	ydot = zeros(3,1); ica =  pml(1)*minfmle(y(1),pml)*(y(1)-pml(4));	if t>=iext(2) & t<iext(3)	   ydot(1) = (iext(1) -ica - ...	     pml(2)*y(2)*(y(1)-pml(5)) - pml(19)*y(3)/(y(3)+pml(21))*(y(1)-pml(5)) - ...		 pml(3)*(y(1)-pml(6)))/pml(14);	else	   ydot(1) = (-ica - ...	     pml(2)*y(2)*(y(1)-pml(5)) - pml(19)*y(3)/(y(3)+pml(21))*(y(1)-pml(5)) - ...		 pml(3)*(y(1)-pml(6)))/pml(14);	end	ydot(2) = pml(7)*(winfmle(y(1),pml)-y(2))/tauw(y(1),pml);	ydot(3) = pml(17)*(-pml(18)*ica - y(3));returnfunction jac = morlecjac3(t,y)%          1    2   3   4    5   6   7    8   9  10  11  12  13  14 15   16%    pml=[gca, gk, gl, vca, vk, vl, phi, v1, v2, v3, v4, v5, v6, C, vic, wic, ...%			    17  18   19    20   21%              eps, mu, gkca, Caic, Kc]'    [pml,~] = getMLEparms3;	jac = zeros(3,3);	jac(1,1) = (-pml(1)*0.5/(pml(9)*(cosh((y(1)-pml(8))/pml(9)))^2)*(y(1)-pml(4)) - ...	       pml(1)*minfmle(y(1),pml) - pml(2)*y(2) - pml(19)*y(3)/(y(3)+pml(21)) - ...		   pml(3))/pml(14);	jac(1,2) = -pml(2)*(y(1)-pml(5))/pml(14);	jac(1,3) = (-pml(19)*(y(1)-pml(5))*pml(21)/(y(3)+pml(21))^2)/pml(14);	jac(2,1) = pml(7)*(0.5/ ...	     (pml(11)*cosh((y(1)-pml(10))/pml(11))^2*tauw(y(1),pml)) - ...		 (winfmle(y(1),pml)-y(2))*sinh((y(1)-pml(12))/pml(13))/(2*pml(13)));	jac(2,2) = -pml(7)/tauw(y(1),pml);	jac(2,3) = 0;	jac(3,1) = -pml(17)*pml(18)*pml(1)*(0.5/ ...	        (pml(9)*(cosh((y(1)-pml(8))/pml(9)))^2)*(y(1)-pml(4)) + minfmle(y(1),pml));	jac(3,2) = 0;	jac(3,3) = -pml(17);returnfunction [tsp,y0,opt]=init3(pml)   tsp = [0; 50];   y0 = [pml(15); pml(16); pml(20)];   opt = [];return% MINFMLE - mvalues = minfmle(vs, pml). minf for MLE eqnsfunction min = minfmle(v,pml)   min = 0.5*(1 + tanh((v-pml(8))/pml(9)));return% TAUW - tauWvalue = tauw(V, pml)function tw = tauw(v,pml)   tw = 1/cosh((v-pml(12))/(2*pml(13)));return% WINFMLE - winfvals = winfmle(vvals, pml).  winf function for MLE eqnsfunction win = winfmle(v,pml)   win = 0.5*(1 + tanh((v-pml(10))/pml(11)));returnfunction [pml3,iext] = getmleparms3% Returns current values of MLE parameters for 3 state-variable model.% pml3 is a column vector of params%    pml=[gca, gk, gl, vca, vk, vl, phi, v1, v2, v3, v4, v5, v6 C vic wic ...%           eps, mu, gcka, Caic, Kc]'% and iext is a column vector describing the external current%	iext = [iampl, tstart, tstop]'global PML3XYZ IEXTXYZpml3 = PML3XYZ;iext = IEXTXYZ;returnfunction setmleparms3(pml3, iext)% Sets current values of MLE parameters for 3 state variable model.% pml3 is a column vector of params%    pml3=[gca, gk, gl, vca, vk, vl, phi, v1, v2, v3, v4, v5, v6 C vic wic ...%             eps, mu, gkca, Caic, Kc]'% and iext is a column vector describing the external current%	iext = [iampl, tstart, tstop]'global PML3XYZ IEXTXYZPML3XYZ = pml3;IEXTXYZ = iext;return